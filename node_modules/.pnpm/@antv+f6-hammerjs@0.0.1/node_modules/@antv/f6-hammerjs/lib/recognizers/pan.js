"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _attribute = _interopRequireDefault(require("./attribute"));

var _inputConsts = require("../inputjs/input-consts");

var _recognizerConsts = require("../recognizerjs/recognizer-consts");

var _touchactionConsts = require("../touchactionjs/touchaction-Consts");

var _directionStr = _interopRequireDefault(require("../recognizerjs/direction-str"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
class PanRecognizer extends _attribute.default {
  constructor() {
    super(...arguments);
    this.pX = null;
    this.pY = null;
  }

  getTouchAction() {
    let {
      options: {
        direction
      }
    } = this;
    let actions = [];

    if (direction & _inputConsts.DIRECTION_HORIZONTAL) {
      actions.push(_touchactionConsts.TOUCH_ACTION_PAN_Y);
    }

    if (direction & _inputConsts.DIRECTION_VERTICAL) {
      actions.push(_touchactionConsts.TOUCH_ACTION_PAN_X);
    }

    return actions;
  }

  directionTest(input) {
    let {
      options
    } = this;
    let hasMoved = true;
    let {
      distance
    } = input;
    let {
      direction
    } = input;
    let x = input.deltaX;
    let y = input.deltaY; // lock to axis?

    if (!(direction & options.direction)) {
      if (options.direction & _inputConsts.DIRECTION_HORIZONTAL) {
        direction = x === 0 ? _inputConsts.DIRECTION_NONE : x < 0 ? _inputConsts.DIRECTION_LEFT : _inputConsts.DIRECTION_RIGHT;
        hasMoved = x !== this.pX;
        distance = Math.abs(input.deltaX);
      } else {
        direction = y === 0 ? _inputConsts.DIRECTION_NONE : y < 0 ? _inputConsts.DIRECTION_UP : _inputConsts.DIRECTION_DOWN;
        hasMoved = y !== this.pY;
        distance = Math.abs(input.deltaY);
      }
    }

    input.direction = direction;
    return hasMoved && distance > options.threshold && direction & options.direction;
  }

  attrTest(input) {
    return _attribute.default.prototype.attrTest.call(this, input) && ( // replace with a super call
    this.state & _recognizerConsts.STATE_BEGAN || !(this.state & _recognizerConsts.STATE_BEGAN) && this.directionTest(input));
  }

  emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    let direction = (0, _directionStr.default)(input.direction);

    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }

    super.emit(input);
  }

}

exports.default = PanRecognizer;
PanRecognizer.prototype.defaults = {
  event: 'pan',
  threshold: 10,
  pointers: 1,
  direction: _inputConsts.DIRECTION_ALL
};