"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _setTimeoutContext = _interopRequireDefault(require("../utils/set-timeout-context"));

var _recognizerConstructor = _interopRequireDefault(require("../recognizerjs/recognizer-constructor"));

var _touchactionConsts = require("../touchactionjs/touchaction-Consts");

var _inputConsts = require("../inputjs/input-consts");

var _recognizerConsts = require("../recognizerjs/recognizer-consts");

var _getDistance = _interopRequireDefault(require("../inputjs/get-distance"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
class TapRecognizer extends _recognizerConstructor.default {
  constructor() {
    super(...arguments); // previous time and center,
    // used for tap counting

    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }

  getTouchAction() {
    return [_touchactionConsts.TOUCH_ACTION_MANIPULATION];
  }

  process(input) {
    let {
      options
    } = this;
    let validPointers = input.pointers.length === options.pointers;
    let validMovement = input.distance < options.threshold;
    let validTouchTime = input.deltaTime < options.time;
    this.reset();

    if (input.eventType & _inputConsts.INPUT_START && this.count === 0) {
      return this.failTimeout();
    } // we only allow little movement
    // and we've reached an end event, so a tap is possible


    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== _inputConsts.INPUT_END) {
        return this.failTimeout();
      }

      let validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      let validMultiTap = !this.pCenter || (0, _getDistance.default)(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;

      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }

      this._input = input; // if tap count matches we have recognized it,
      // else it has began recognizing...

      let tapCount = this.count % options.taps;

      if (tapCount === 0) {
        // no failing requirements, immediately trigger the tap event
        // or wait as long as the multitap interval to trigger
        if (!this.hasRequireFailures()) {
          return _recognizerConsts.STATE_RECOGNIZED;
        } else {
          this._timer = (0, _setTimeoutContext.default)(() => {
            this.state = _recognizerConsts.STATE_RECOGNIZED;
            this.tryEmit();
          }, options.interval, this);
          return _recognizerConsts.STATE_BEGAN;
        }
      }
    }

    return _recognizerConsts.STATE_FAILED;
  }

  failTimeout() {
    this._timer = (0, _setTimeoutContext.default)(() => {
      this.state = _recognizerConsts.STATE_FAILED;
    }, this.options.interval, this);
    return _recognizerConsts.STATE_FAILED;
  }

  reset() {
    clearTimeout(this._timer);
    this._timer = null;
  }

  emit() {
    if (this.state === _recognizerConsts.STATE_RECOGNIZED) {
      this._input.tapCount = this.count;
      this.manager.emit(this.options.event, this._input);
    }
  }

}

exports.default = TapRecognizer;
TapRecognizer.prototype.defaults = {
  event: 'tap',
  pointers: 1,
  taps: 1,
  interval: 300,
  // max time between the multi-tap taps
  time: 250,
  // max time of the pointer to be down (like finger on the screen)
  threshold: 9,
  // a minimal movement is ok, but keep it low
  posThreshold: 10 // a multi-tap can be a bit off the initial position

};