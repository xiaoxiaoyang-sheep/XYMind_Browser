"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _inputConsts = require("../inputjs/input-consts");

var _inputConstructor = _interopRequireDefault(require("../inputjs/input-constructor"));

var _toArray = _interopRequireDefault(require("../utils/to-array"));

var _hasParent = _interopRequireDefault(require("../utils/has-parent"));

var _uniqueArray = _interopRequireDefault(require("../utils/unique-array"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TOUCH_INPUT_MAP = {
  touchstart: _inputConsts.INPUT_START,
  touchmove: _inputConsts.INPUT_MOVE,
  touchend: _inputConsts.INPUT_END,
  touchcancel: _inputConsts.INPUT_CANCEL
};
const TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
/**
 * @private
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */

class TouchInput extends _inputConstructor.default {
  constructor() {
    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
    TouchInput.prototype.targetIds = {};
    TouchInput.prototype.events = TOUCH_TARGET_EVENTS;
    super(...arguments);
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
  }

  handler(ev) {
    let type = TOUCH_INPUT_MAP[ev.type];
    let touches = getTouches.call(this, ev, type);

    if (!touches) {
      return;
    }

    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: _inputConsts.INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  }

}
/**
 * @private
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */


exports.default = TouchInput;

function getTouches(ev, type) {
  let allTouches = (0, _toArray.default)(ev.touches);
  let {
    targetIds
  } = this; // when there is only one touch, the process can be simplified

  if (type & (_inputConsts.INPUT_START | _inputConsts.INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }

  let i;
  let targetTouches;
  let changedTouches = (0, _toArray.default)(ev.changedTouches);
  let changedTargetTouches = [];
  let {
    target
  } = this; //// get target touches from touches 小程序下targets是空，不太需要
  //targetTouches = allTouches.filter((touch) => {
  //  return hasParent(touch.target, target);
  //});

  targetTouches = allTouches; // collect touches

  if (type === _inputConsts.INPUT_START) {
    i = 0;

    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  } // filter changed touches to only contain touches that exist in the collected target ids


  i = 0;

  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    } // cleanup removed touches


    if (type & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }

    i++;
  }

  if (!changedTargetTouches.length) {
    return;
  }

  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
  (0, _uniqueArray.default)(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
}