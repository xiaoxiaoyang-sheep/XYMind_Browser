"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _touchactionConsts = require("./touchaction-Consts");

var _inputConsts = require("../inputjs/input-consts");

var _each = _interopRequireDefault(require("../utils/each"));

var _boolOrFn = _interopRequireDefault(require("../utils/bool-or-fn"));

var _inStr = _interopRequireDefault(require("../utils/in-str"));

var _cleanTouchActions = _interopRequireDefault(require("./clean-touch-actions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
class TouchAction {
  constructor(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  /**
   * @private
   * set the touchAction value on the element or enable the polyfill
   * @param {String} value
   */


  set(value) {
    // find out the touch-action by the event handlers
    if (value === _touchactionConsts.TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }

    this.actions = value.toLowerCase().trim();
  }
  /**
   * @private
   * just re-set the touchAction value
   */


  update() {
    this.set(this.manager.options.touchAction);
  }
  /**
   * @private
   * compute the value for the touchAction property based on the recognizer's settings
   * @returns {String} value
   */


  compute() {
    let actions = [];
    (0, _each.default)(this.manager.recognizers, recognizer => {
      if ((0, _boolOrFn.default)(recognizer.options.enable, [recognizer])) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    });
    return (0, _cleanTouchActions.default)(actions.join(' '));
  }
  /**
   * @private
   * this method is called on each input cycle and provides the preventing of the browser behavior
   * @param {Object} input
   */


  preventDefaults(input) {
    let {
      srcEvent
    } = input;
    let direction = input.offsetDirection; // if the touch action did prevented once this session

    if (this.manager.session.prevented) {
      srcEvent.preventDefault();
      return;
    }

    let {
      actions
    } = this;
    let hasNone = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_NONE) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_NONE];
    let hasPanY = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_Y) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_PAN_Y];
    let hasPanX = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_X) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_PAN_X];

    if (hasNone) {
      // do not prevent defaults if this is a tap gesture
      let isTapPointer = input.pointers.length === 1;
      let isTapMovement = input.distance < 2;
      let isTapTouchTime = input.deltaTime < 250;

      if (isTapPointer && isTapMovement && isTapTouchTime) {
        return;
      }
    }

    if (hasPanX && hasPanY) {
      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
      return;
    }

    if (hasNone || hasPanY && direction & _inputConsts.DIRECTION_HORIZONTAL || hasPanX && direction & _inputConsts.DIRECTION_VERTICAL) {
      return this.preventSrc(srcEvent);
    }
  }
  /**
   * @private
   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
   * @param {Object} srcEvent
   */


  preventSrc(srcEvent) {
    this.manager.session.prevented = true;
    srcEvent.preventDefault();
  }

}

exports.default = TouchAction;