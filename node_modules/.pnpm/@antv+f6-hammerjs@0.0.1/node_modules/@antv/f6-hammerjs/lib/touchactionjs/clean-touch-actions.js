"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanTouchActions;

var _inStr = _interopRequireDefault(require("../utils/in-str"));

var _touchactionConsts = require("./touchaction-Consts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
  // none
  if ((0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_NONE)) {
    return _touchactionConsts.TOUCH_ACTION_NONE;
  }

  let hasPanX = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_X);
  let hasPanY = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
  // for different directions, e.g. horizontal pan but vertical swipe?)
  // we need none (as otherwise with pan-x pan-y combined none of these
  // recognizers will work, since the browser would handle all panning

  if (hasPanX && hasPanY) {
    return _touchactionConsts.TOUCH_ACTION_NONE;
  } // pan-x OR pan-y


  if (hasPanX || hasPanY) {
    return hasPanX ? _touchactionConsts.TOUCH_ACTION_PAN_X : _touchactionConsts.TOUCH_ACTION_PAN_Y;
  } // manipulation


  if ((0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_MANIPULATION)) {
    return _touchactionConsts.TOUCH_ACTION_MANIPULATION;
  }

  return _touchactionConsts.TOUCH_ACTION_AUTO;
}