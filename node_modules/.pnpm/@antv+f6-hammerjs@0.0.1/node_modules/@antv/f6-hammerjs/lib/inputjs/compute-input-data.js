"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = computeInputData;

var _utilsConsts = require("../utils/utils-consts");

var _hasParent = _interopRequireDefault(require("../utils/has-parent"));

var _simpleCloneInputData = _interopRequireDefault(require("./simple-clone-input-data"));

var _getCenter = _interopRequireDefault(require("./get-center"));

var _getDistance = _interopRequireDefault(require("./get-distance"));

var _getAngle = _interopRequireDefault(require("./get-angle"));

var _getDirection = _interopRequireDefault(require("./get-direction"));

var _computeDeltaXy = _interopRequireDefault(require("./compute-delta-xy"));

var _getVelocity = _interopRequireDefault(require("./get-velocity"));

var _getScale = _interopRequireDefault(require("./get-scale"));

var _getRotation = _interopRequireDefault(require("./get-rotation"));

var _computeIntervalInputData = _interopRequireDefault(require("./compute-interval-input-data"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
  let {
    session
  } = manager;
  let {
    pointers
  } = input;
  let {
    length: pointersLength
  } = pointers; // store the first input to calculate the distance and direction

  if (!session.firstInput) {
    session.firstInput = (0, _simpleCloneInputData.default)(input);
  } // to compute scale and rotation we need to store the multiple touches


  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = (0, _simpleCloneInputData.default)(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }

  let {
    firstInput,
    firstMultiple
  } = session;
  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  let center = input.center = (0, _getCenter.default)(pointers);
  input.timeStamp = (0, _utilsConsts.now)();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = (0, _getAngle.default)(offsetCenter, center);
  input.distance = (0, _getDistance.default)(offsetCenter, center);
  (0, _computeDeltaXy.default)(session, input);
  input.offsetDirection = (0, _getDirection.default)(input.deltaX, input.deltaY);
  let overallVelocity = (0, _getVelocity.default)(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = (0, _utilsConsts.abs)(overallVelocity.x) > (0, _utilsConsts.abs)(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? (0, _getScale.default)(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? (0, _getRotation.default)(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  (0, _computeIntervalInputData.default)(session, input);
}