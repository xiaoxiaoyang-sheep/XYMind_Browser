{"version":3,"file":"hammer.min.js","mappings":"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","sources":["webpack://hammer/webpack/universalModuleDefinition","webpack://hammer/webpack/bootstrap","webpack://hammer/webpack/runtime/define property getters","webpack://hammer/webpack/runtime/hasOwnProperty shorthand","webpack://hammer/webpack/runtime/make namespace object","webpack://hammer/./src/utils/if-undefined.js","webpack://hammer/./src/utils/utils-consts.js","webpack://hammer/./src/touchactionjs/get-touchaction-props.js","webpack://hammer/./src/touchactionjs/touchaction-Consts.js","webpack://hammer/./src/inputjs/input-consts.js","webpack://hammer/./src/recognizerjs/recognizer-consts.js","webpack://hammer/./src/utils/assign.js","webpack://hammer/./src/utils/unique-id.js","webpack://hammer/./src/utils/each.js","webpack://hammer/./src/utils/invoke-array-arg.js","webpack://hammer/./src/utils/in-array.js","webpack://hammer/./src/utils/bool-or-fn.js","webpack://hammer/./src/recognizerjs/get-recognizer-by-name-if-manager.js","webpack://hammer/./src/recognizerjs/state-str.js","webpack://hammer/./src/recognizerjs/recognizer-constructor.js","webpack://hammer/./src/recognizers/attribute.js","webpack://hammer/./src/recognizers/rotate.js","webpack://hammer/./src/recognizers/pinch.js","webpack://hammer/./src/recognizerjs/direction-str.js","webpack://hammer/./src/recognizers/pan.js","webpack://hammer/./src/recognizers/swipe.js","webpack://hammer/./src/utils/bind-fn.js","webpack://hammer/./src/utils/set-timeout-context.js","webpack://hammer/./src/inputjs/get-distance.js","webpack://hammer/./src/recognizers/tap.js","webpack://hammer/./src/recognizers/press.js","webpack://hammer/./src/utils/in-str.js","webpack://hammer/./src/touchactionjs/touchaction-constructor.js","webpack://hammer/./src/touchactionjs/clean-touch-actions.js","webpack://hammer/./src/inputjs/get-center.js","webpack://hammer/./src/inputjs/simple-clone-input-data.js","webpack://hammer/./src/inputjs/get-angle.js","webpack://hammer/./src/inputjs/get-direction.js","webpack://hammer/./src/inputjs/get-velocity.js","webpack://hammer/./src/inputjs/input-handler.js","webpack://hammer/./src/inputjs/compute-input-data.js","webpack://hammer/./src/inputjs/compute-delta-xy.js","webpack://hammer/./src/inputjs/get-scale.js","webpack://hammer/./src/inputjs/get-rotation.js","webpack://hammer/./src/inputjs/compute-interval-input-data.js","webpack://hammer/./src/utils/split-str.js","webpack://hammer/./src/utils/add-event-listeners.js","webpack://hammer/./src/inputjs/input-constructor.js","webpack://hammer/./src/utils/to-array.js","webpack://hammer/./src/utils/unique-array.js","webpack://hammer/./src/input/touch.js","webpack://hammer/./src/manager.js","webpack://hammer/./src/inputjs/create-input-instance.js","webpack://hammer/./src/hammer.js","webpack://hammer/./src/input/pointerevent.js","webpack://hammer/./src/utils/remove-event-listeners.js","webpack://hammer/./src/utils/deprecate.js","webpack://hammer/./src/utils/extend.js","webpack://hammer/./src/utils/merge.js","webpack://hammer/./src/index.js","webpack://hammer/./src/utils/inherit.js","webpack://hammer/./src/utils/has-parent.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hammer\"] = factory();\n\telse\n\t\troot[\"hammer\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @private\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nexport default function ifUndefined(val1, val2) {\n  return val1 === undefined ? val2 : val1;\n}\n","const TYPE_FUNCTION = 'function';\n\nconst { round, abs } = Math;\nconst { now } = Date;\n\nexport { TYPE_FUNCTION, round, abs, now };\n","export default function getTouchActionProps() {\n  let touchMap = {};\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(\n    (val) => {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      return (touchMap[val] = true);\n    },\n  );\n  return touchMap;\n}\n","import { TEST_ELEMENT } from '../utils/utils-consts';\nimport getTouchActionProps from './get-touchaction-props';\n\n// magical touchAction value\nconst TOUCH_ACTION_COMPUTE = 'compute';\nconst TOUCH_ACTION_AUTO = 'auto';\nconst TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nconst TOUCH_ACTION_NONE = 'none';\nconst TOUCH_ACTION_PAN_X = 'pan-x';\nconst TOUCH_ACTION_PAN_Y = 'pan-y';\nconst TOUCH_ACTION_MAP = getTouchActionProps();\n\nexport {\n  TOUCH_ACTION_AUTO,\n  TOUCH_ACTION_COMPUTE,\n  TOUCH_ACTION_MANIPULATION,\n  TOUCH_ACTION_NONE,\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n  TOUCH_ACTION_MAP,\n};\n","const INPUT_TYPE_TOUCH = 'touch';\nconst INPUT_TYPE_PEN = 'pen';\nconst INPUT_TYPE_MOUSE = 'mouse';\nconst INPUT_TYPE_KINECT = 'kinect';\n\nconst COMPUTE_INTERVAL = 25;\n\nconst INPUT_START = 1;\nconst INPUT_MOVE = 2;\nconst INPUT_END = 4;\nconst INPUT_CANCEL = 8;\n\nconst DIRECTION_NONE = 1;\nconst DIRECTION_LEFT = 2;\nconst DIRECTION_RIGHT = 4;\nconst DIRECTION_UP = 8;\nconst DIRECTION_DOWN = 16;\n\nconst DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nconst DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nconst DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nconst PROPS_XY = ['x', 'y'];\nconst PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\nexport {\n  INPUT_TYPE_KINECT,\n  INPUT_TYPE_MOUSE,\n  INPUT_TYPE_PEN,\n  INPUT_TYPE_TOUCH,\n  COMPUTE_INTERVAL,\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n  PROPS_XY,\n  PROPS_CLIENT_XY,\n};\n","const STATE_POSSIBLE = 1;\nconst STATE_BEGAN = 2;\nconst STATE_CHANGED = 4;\nconst STATE_ENDED = 8;\nconst STATE_RECOGNIZED = STATE_ENDED;\nconst STATE_CANCELLED = 16;\nconst STATE_FAILED = 32;\n\nexport {\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n};\n","/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nlet assign;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    let output = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nexport default assign;\n","/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nlet _uniqueId = 1;\nexport default function uniqueId() {\n  return _uniqueId++;\n}\n","/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nexport default function each(obj, iterator, context) {\n  let i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n","import each from './each';\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nexport default function invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\n","/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nexport default function inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    let i = 0;\n    while (i < src.length) {\n      if (\n        (findByKey && src[i][findByKey] == find) ||\n        (!findByKey && src[i] === find)\n      ) {\n        // do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\n","import { TYPE_FUNCTION } from './utils-consts';\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nexport default function boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n","/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nexport default function getRecognizerByNameIfManager(\n  otherRecognizer,\n  recognizer,\n) {\n  let { manager } = recognizer;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n","import {\n  STATE_CANCELLED,\n  STATE_ENDED,\n  STATE_CHANGED,\n  STATE_BEGAN,\n} from './recognizer-consts';\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\nexport default function stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n","import {\n  STATE_POSSIBLE,\n  STATE_ENDED,\n  STATE_FAILED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_BEGAN,\n  STATE_CHANGED,\n} from './recognizer-consts';\nimport assign from '../utils/assign';\nimport uniqueId from '../utils/unique-id';\nimport ifUndefined from '../utils/if-undefined';\nimport invokeArrayArg from '../utils/invoke-array-arg';\nimport inArray from '../utils/in-array';\nimport boolOrFn from '../utils/bool-or-fn';\nimport getRecognizerByNameIfManager from './get-recognizer-by-name-if-manager';\nimport stateStr from './state-str';\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nexport default class Recognizer {\n  constructor(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n  set(options) {\n    assign(this.options, options);\n\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager && this.manager.touchAction.update();\n    return this;\n  }\n\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    let { simultaneous } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  }\n\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    let { requireFail } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    let index = inArray(this.requireFail, otherRecognizer);\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n  hasRequireFailures() {\n    return this.requireFail.length > 0;\n  }\n\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n  canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  }\n\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n  emit(input) {\n    let self = this;\n    let { state } = this;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    }\n\n    // 'panstart' and 'panmove'\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    }\n\n    // panend and pancancel\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  }\n\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n  tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    }\n    // it's failing anyway\n    this.state = STATE_FAILED;\n  }\n\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n  canEmit() {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n  recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    let inputDataClone = assign({}, inputData);\n\n    // is is enabled and allow recognizing?\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    }\n\n    // reset when we've reached the end\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (\n      this.state &\n      (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)\n    ) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n  process(inputData) {}\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n  getTouchAction() {}\n\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n  reset() {}\n}\n\nRecognizer.prototype.defaults = {};\n","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_CANCELLED,\n  STATE_ENDED,\n  STATE_FAILED,\n} from '../recognizerjs/recognizer-consts';\nimport { INPUT_CANCEL, INPUT_END } from '../inputjs/input-consts';\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nexport default class AttrRecognizer extends Recognizer {\n  constructor() {\n    super(...arguments);\n  }\n\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n  attrTest(input) {\n    let optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  }\n\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n  process(input) {\n    let { state } = this;\n    let { eventType } = input;\n\n    let isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    let isValid = this.attrTest(input);\n\n    // on cancel input and we've recognized before, return STATE_CANCELLED\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  }\n}\n\nAttrRecognizer.prototype.defaults = {\n  /**\n   * @private\n   * @type {Number}\n   * @default 1\n   */\n  pointers: 1,\n};\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class RotateRecognizer extends AttrRecognizer {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return (\n      super.attrTest(input) &&\n      (Math.abs(input.rotation) > this.options.threshold ||\n        this.state & STATE_BEGAN)\n    );\n  }\n}\n\nRotateRecognizer.prototype.defaults = {\n  event: 'rotate',\n  threshold: 0,\n  pointers: 2,\n};\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PinchRecognizer extends AttrRecognizer {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return (\n      super.attrTest(input) &&\n      (Math.abs(input.scale - 1) > this.options.threshold ||\n        this.state & STATE_BEGAN)\n    );\n  }\n\n  emit(input) {\n    if (input.scale !== 1) {\n      let inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    super.emit(input);\n  }\n}\n\nPinchRecognizer.prototype.defaults = {\n  event: 'pinch',\n  threshold: 0,\n  pointers: 2,\n};\n","import {\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\nexport default function directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n","import AttrRecognizer from './attribute';\nimport {\n  DIRECTION_ALL,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_NONE,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n} from '../inputjs/input-consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\nimport {\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n} from '../touchactionjs/touchaction-Consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PanRecognizer extends AttrRecognizer {\n  constructor() {\n    super(...arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction() {\n    let {\n      options: { direction },\n    } = this;\n    let actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n\n  directionTest(input) {\n    let { options } = this;\n    let hasMoved = true;\n    let { distance } = input;\n    let { direction } = input;\n    let x = input.deltaX;\n    let y = input.deltaY;\n\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction =\n          x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction =\n          y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return (\n      hasMoved && distance > options.threshold && direction & options.direction\n    );\n  }\n\n  attrTest(input) {\n    return (\n      AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call\n      (this.state & STATE_BEGAN ||\n        (!(this.state & STATE_BEGAN) && this.directionTest(input)))\n    );\n  }\n\n  emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n\n    let direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}\n\nPanRecognizer.prototype.defaults = {\n  event: 'pan',\n  threshold: 10,\n  pointers: 1,\n  direction: DIRECTION_ALL,\n};\n","import AttrRecognizer from '../recognizers/attribute';\nimport { abs } from '../utils/utils-consts';\nimport {\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n} from '../inputjs/input-consts';\nimport PanRecognizer from './pan';\nimport { INPUT_END } from '../inputjs/input-consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class SwipeRecognizer extends AttrRecognizer {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n\n  attrTest(input) {\n    let { direction } = this.options;\n    let velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return (\n      super.attrTest(input) &&\n      direction & input.offsetDirection &&\n      input.distance > this.options.threshold &&\n      input.maxPointers === this.options.pointers &&\n      abs(velocity) > this.options.velocity &&\n      input.eventType & INPUT_END\n    );\n  }\n\n  emit(input) {\n    let direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n}\n\nSwipeRecognizer.prototype.defaults = {\n  event: 'swipe',\n  threshold: 10,\n  velocity: 0.3,\n  direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n  pointers: 1,\n};\n","/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nexport default function bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n","import bindFn from './bind-fn';\n\n/**\n * @private\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nexport default function setTimeoutContext(fn, timeout, context) {\n  return setTimeout(bindFn(fn, context), timeout);\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nexport default function getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n\n  return Math.sqrt(x * x + y * y);\n}\n","import setTimeoutContext from '../utils/set-timeout-context';\nimport Recognizer from '../recognizerjs/recognizer-constructor';\nimport { TOUCH_ACTION_MANIPULATION } from '../touchactionjs/touchaction-Consts';\nimport { INPUT_START, INPUT_END } from '../inputjs/input-consts';\nimport {\n  STATE_RECOGNIZED,\n  STATE_BEGAN,\n  STATE_FAILED,\n} from '../recognizerjs/recognizer-consts';\nimport getDistance from '../inputjs/get-distance';\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nexport default class TapRecognizer extends Recognizer {\n  constructor() {\n    super(...arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input) {\n    let { options } = this;\n\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTouchTime = input.deltaTime < options.time;\n\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    }\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      let validInterval = this.pTime\n        ? input.timeStamp - this.pTime < options.interval\n        : true;\n      let validMultiTap =\n        !this.pCenter ||\n        getDistance(this.pCenter, input.center) < options.posThreshold;\n\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      let tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeoutContext(\n            () => {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            },\n            options.interval,\n            this,\n          );\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  }\n\n  failTimeout() {\n    this._timer = setTimeoutContext(\n      () => {\n        this.state = STATE_FAILED;\n      },\n      this.options.interval,\n      this,\n    );\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n    this._timer = null;\n  }\n\n  emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n\nTapRecognizer.prototype.defaults = {\n  event: 'tap',\n  pointers: 1,\n  taps: 1,\n  interval: 300, // max time between the multi-tap taps\n  time: 250, // max time of the pointer to be down (like finger on the screen)\n  threshold: 9, // a minimal movement is ok, but keep it low\n  posThreshold: 10, // a multi-tap can be a bit off the initial position\n};\n","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n  STATE_RECOGNIZED,\n  STATE_FAILED,\n} from '../recognizerjs/recognizer-consts';\nimport { now } from '../utils/utils-consts';\nimport setTimeoutContext from '../utils/set-timeout-context';\nimport { TOUCH_ACTION_AUTO } from '../touchactionjs/touchaction-Consts';\nimport { INPUT_START, INPUT_END, INPUT_CANCEL } from '../inputjs/input-consts';\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nexport default class PressRecognizer extends Recognizer {\n  constructor() {\n    super(...arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n\n  process(input) {\n    let { options } = this;\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTime = input.deltaTime > options.time;\n\n    this._input = input;\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (\n      !validMovement ||\n      !validPointers ||\n      (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)\n    ) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeoutContext(\n        () => {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        },\n        options.time,\n        this,\n      );\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n    this._timer = null;\n  }\n\n  emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n\nPressRecognizer.prototype.defaults = {\n  event: 'press',\n  pointers: 1,\n  time: 251, // minimal time of the pointer to be pressed\n  threshold: 9, // a minimal movement is ok, but keep it low\n};\n","/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nexport default function inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n","import {\n  TOUCH_ACTION_COMPUTE,\n  TOUCH_ACTION_MAP,\n  TOUCH_ACTION_NONE,\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n} from './touchaction-Consts';\nimport {\n  DIRECTION_VERTICAL,\n  DIRECTION_HORIZONTAL,\n} from '../inputjs/input-consts';\nimport each from '../utils/each';\nimport boolOrFn from '../utils/bool-or-fn';\nimport inStr from '../utils/in-str';\nimport cleanTouchActions from './clean-touch-actions';\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nexport default class TouchAction {\n  constructor(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n  set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    this.actions = value.toLowerCase().trim();\n  }\n\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n  update() {\n    this.set(this.manager.options.touchAction);\n  }\n\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n  compute() {\n    let actions = [];\n    each(this.manager.recognizers, (recognizer) => {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  }\n\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n  preventDefaults(input) {\n    let { srcEvent } = input;\n    let direction = input.offsetDirection;\n\n    // if the touch action did prevented once this session\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    let { actions } = this;\n    let hasNone =\n      inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    let hasPanY =\n      inStr(actions, TOUCH_ACTION_PAN_Y) &&\n      !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    let hasPanX =\n      inStr(actions, TOUCH_ACTION_PAN_X) &&\n      !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      let isTapPointer = input.pointers.length === 1;\n      let isTapMovement = input.distance < 2;\n      let isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (\n      hasNone ||\n      (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n      (hasPanX && direction & DIRECTION_VERTICAL)\n    ) {\n      return this.preventSrc(srcEvent);\n    }\n  }\n\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n  preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  }\n}\n","import inStr from '../utils/in-str';\nimport {\n  TOUCH_ACTION_NONE,\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n  TOUCH_ACTION_MANIPULATION,\n  TOUCH_ACTION_AUTO,\n} from './touchaction-Consts';\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nexport default function cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n  // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  // pan-x OR pan-y\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  // manipulation\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n","import { round } from '../utils/utils-consts';\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nexport default function getCenter(pointers) {\n  let pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY),\n    };\n  }\n\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength),\n  };\n}\n","import { now, round } from '../utils/utils-consts';\nimport getCenter from './get-center';\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nexport default function simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  let pointers = [];\n  let i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY),\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY,\n  };\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nexport default function getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n  return (Math.atan2(y, x) * 180) / Math.PI;\n}\n","import { abs } from '../utils/utils-consts';\nimport {\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n} from './input-consts';\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nexport default function getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n","/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nexport default function getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0,\n  };\n}\n","import { INPUT_START, INPUT_END, INPUT_CANCEL } from './input-consts';\nimport computeInputData from './compute-input-data';\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nexport default function inputHandler(manager, eventType, input) {\n  let pointersLen = input.pointers.length;\n  let changedPointersLen = input.changedPointers.length;\n  let isFirst =\n    eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  let isFinal =\n    eventType & (INPUT_END | INPUT_CANCEL) &&\n    pointersLen - changedPointersLen === 0;\n\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n  input.eventType = eventType;\n\n  // compute scale, rotation etc\n  computeInputData(manager, input);\n\n  // emit secret event\n  manager.emit('hammer.input', input);\n\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n","import { now } from '../utils/utils-consts';\nimport { abs } from '../utils/utils-consts';\nimport hasParent from '../utils/has-parent';\nimport simpleCloneInputData from './simple-clone-input-data';\nimport getCenter from './get-center';\nimport getDistance from './get-distance';\nimport getAngle from './get-angle';\nimport getDirection from './get-direction';\nimport computeDeltaXY from './compute-delta-xy';\nimport getVelocity from './get-velocity';\nimport getScale from './get-scale';\nimport getRotation from './get-rotation';\nimport computeIntervalInputData from './compute-interval-input-data';\n\n/**\n * @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nexport default function computeInputData(manager, input) {\n  let { session } = manager;\n  let { pointers } = input;\n  let { length: pointersLength } = pointers;\n\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  let { firstInput, firstMultiple } = session;\n  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  let center = (input.center = getCenter(pointers));\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  let overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity =\n    abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput\n    ? input.pointers.length\n    : input.pointers.length > session.prevInput.maxPointers\n    ? input.pointers.length\n    : session.prevInput.maxPointers;\n\n  computeIntervalInputData(session, input);\n}\n","import { INPUT_START, INPUT_END } from './input-consts';\n\nexport default function computeDeltaXY(session, input) {\n  let { center } = input;\n  // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n  let offset = session.offsetDelta || {};\n  let prevDelta = session.prevDelta || {};\n  let prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0,\n    };\n\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y,\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n","import { PROPS_CLIENT_XY } from './input-consts';\nimport getDistance from './get-distance';\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nexport default function getScale(start, end) {\n  return (\n    getDistance(end[0], end[1], PROPS_CLIENT_XY) /\n    getDistance(start[0], start[1], PROPS_CLIENT_XY)\n  );\n}\n","import getAngle from './get-angle';\nimport { PROPS_CLIENT_XY } from './input-consts';\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nexport default function getRotation(start, end) {\n  return (\n    getAngle(end[1], end[0], PROPS_CLIENT_XY) +\n    getAngle(start[1], start[0], PROPS_CLIENT_XY)\n  );\n}\n","import { INPUT_CANCEL, COMPUTE_INTERVAL } from './input-consts';\nimport { abs } from '../utils/utils-consts';\nimport getVelocity from './get-velocity';\nimport getDirection from './get-direction';\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nexport default function computeIntervalInputData(session, input) {\n  let last = session.lastInterval || input;\n  let deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (\n    input.eventType !== INPUT_CANCEL &&\n    (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)\n  ) {\n    let deltaX = input.deltaX - last.deltaX;\n    let deltaY = input.deltaY - last.deltaY;\n\n    let v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n","/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\nexport default function splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function addEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.addEventListener(type, handler, false);\n  });\n}\n\nexport function addManagerListeners(manager, types, handler) {\n  each(splitStr(types), (type) => {\n    manager.on(`origin_input:${type}`, handler);\n  });\n}\n","import boolOrFn from '../utils/bool-or-fn';\nimport { addManagerListeners } from '../utils/add-event-listeners';\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nexport default class Input {\n  constructor(manager, callback) {\n    let self = this;\n    this.manager = manager;\n    this.callback = callback;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.eventHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n  handler() {}\n\n  /**\n   * @private\n   */\n  init() {\n    addManagerListeners(this.manager, this.events || '', this.eventHandler);\n  }\n\n  /**\n   * @private\n   */\n  destroy() {\n    removeManagerListeners(this.manager, this.events || '', this.eventHandler);\n  }\n}\n","/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nexport default function toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n","import inArray from './in-array';\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nexport default function uniqueArray(src, key, sort) {\n  let results = [];\n  let values = [];\n  let i = 0;\n\n  while (i < src.length) {\n    let val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort((a, b) => {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n","import {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  INPUT_TYPE_TOUCH,\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport hasParent from '../utils/has-parent';\nimport uniqueArray from '../utils/unique-array';\n\nconst TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL,\n};\n\nconst TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nexport default class TouchInput extends Input {\n  constructor() {\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    TouchInput.prototype.targetIds = {};\n    TouchInput.prototype.events = TOUCH_TARGET_EVENTS;\n    super(...arguments);\n\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n  }\n\n  handler(ev) {\n    let type = TOUCH_INPUT_MAP[ev.type];\n    let touches = getTouches.call(this, ev, type);\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev,\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n  let allTouches = toArray(ev.touches);\n  let { targetIds } = this;\n\n  // when there is only one touch, the process can be simplified\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  let i;\n  let targetTouches;\n  let changedTouches = toArray(ev.changedTouches);\n  let changedTargetTouches = [];\n  let { target } = this;\n\n  //// get target touches from touches 小程序下targets是空，不太需要\n  //targetTouches = allTouches.filter((touch) => {\n  //  return hasParent(touch.target, target);\n  //});\n  targetTouches = allTouches;\n\n  // collect touches\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n\n  // filter changed touches to only contain touches that exist in the collected target ids\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n\n    // cleanup removed touches\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n    changedTargetTouches,\n  ];\n}\n","import assign from './utils/assign';\nimport Hammer from './hammer';\nimport TouchAction from './touchactionjs/touchaction-constructor';\nimport createInputInstance from './inputjs/create-input-instance';\nimport each from './utils/each';\nimport inArray from './utils/in-array';\nimport invokeArrayArg from './utils/invoke-array-arg';\nimport splitStr from './utils/split-str';\nimport Recognizer from './recognizerjs/recognizer-constructor';\nimport {\n  STATE_BEGAN,\n  STATE_ENDED,\n  STATE_CHANGED,\n  STATE_RECOGNIZED,\n} from './recognizerjs/recognizer-consts';\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n\n/**\n * @private\n * Manager\n * @param {Object} [options]\n * @constructor\n */\nexport default class Manager {\n  constructor(options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.handlers = {};\n    this.filters = [];\n    this.session = {};\n    this.recognizers = [];\n\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    each(\n      this.options.recognizers,\n      (item) => {\n        let recognizer = this.add(new item[0](item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n      },\n      this,\n    );\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n  set(options) {\n    assign(this.options, options);\n\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    return this;\n  }\n\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n  stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n\n  /**\n   * @private\n   * add event filters\n   */\n  addFilter(filter) {\n    if (typeof filter !== 'function') {\n      throw new Error('filter must be a function');\n    }\n    this.filters.push(filter);\n  }\n\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n  recognize(inputData) {\n    let { session } = this;\n    if (session.stopped) {\n      return;\n    }\n\n    // run the touch-action polyfill\n    this.touchAction.preventDefaults(inputData);\n\n    let recognizer;\n    let { recognizers } = this;\n\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let { curRecognizer } = session;\n\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (\n      !curRecognizer ||\n      (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)\n    ) {\n      curRecognizer = session.curRecognizer = null;\n    }\n\n    let i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (\n        session.stopped !== FORCED_STOP && // 1\n        (!curRecognizer ||\n          recognizer === curRecognizer || // 2\n          recognizer.canRecognizeWith(curRecognizer))\n      ) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (\n        !curRecognizer &&\n        recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)\n      ) {\n        curRecognizer = session.curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n  get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    let { recognizers } = this;\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n  add(recognizer) {\n    if (invokeArrayArg(recognizer, 'add', this)) {\n      return this;\n    }\n\n    // remove existing\n    let existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n\n    this.touchAction.update();\n    return recognizer;\n  }\n\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n  remove(recognizer) {\n    if (invokeArrayArg(recognizer, 'remove', this)) {\n      return this;\n    }\n\n    recognizer = this.get(recognizer);\n\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      let { recognizers } = this;\n      let index = inArray(recognizers, recognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n  on(events, handler) {\n    if (events === undefined) {\n      return;\n    }\n    if (handler === undefined) {\n      return;\n    }\n\n    let { handlers } = this;\n    each(splitStr(events), (event) => {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  }\n\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n  off(events, handler) {\n    if (events === undefined) {\n      return;\n    }\n\n    let { handlers } = this;\n    each(splitStr(events), (event) => {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] &&\n          handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n  emit(event, data) {\n    // no handlers, so skip it all\n    let handlers = this.handlers[event] && this.handlers[event].slice();\n    const { filters } = this;\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    //let i = 0;\n    //let newData = Object.assign(data);\n    //data.type = event;\n    //data.preventDefault = function() {\n    //  data.srcEvent.preventDefault();\n    //};\n\n    //while (i < filters.length) {\n    //  newData = filters[i](newData);\n    //  i++;\n    //}\n    //\n    if (!event.startsWith('origin_input')) {\n      data.type = event;\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault && data.srcEvent.preventDefault();\n      };\n    }\n\n    let i = 0;\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  }\n\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n  destroy() {\n    this.handlers = {};\n    this.filters = [];\n    this.session = {};\n    this.input.destroy();\n  }\n}\n","import inputHandler from './input-handler';\nimport TouchInput from '../input/touch';\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nexport default function createInputInstance(manager) {\n  let Type = TouchInput;\n  if (manager.options.inputClass) {\n    Type = inputClass;\n  }\n  return new Type(manager, inputHandler);\n}\n","import ifUndefined from './utils/if-undefined';\nimport { TOUCH_ACTION_COMPUTE } from './touchactionjs/touchaction-Consts';\nimport { DIRECTION_HORIZONTAL } from './inputjs/input-consts';\nimport RotateRecognizer from './recognizers/rotate';\nimport PinchRecognizer from './recognizers/pinch';\nimport SwipeRecognizer from './recognizers/swipe';\nimport PanRecognizer from './recognizers/pan';\nimport TapRecognizer from './recognizers/tap';\nimport PressRecognizer from './recognizers/press';\nimport Manager from './manager';\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {Object} [options]\n * @constructor\n */\nexport default class Hammer {\n  constructor(options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(options);\n  }\n}\n\n/**\n * @private\n * default settings\n * @namespace\n */\nHammer.defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Default recognizer setup when calling `Hammer()`\n   * When creating a new Manager these will be skipped.\n   * @type {Array}\n   */\n  preset: [\n    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, { enable: false }],\n    [PinchRecognizer, { enable: false }, ['rotate']],\n    [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n    [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n    [TapRecognizer],\n    [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n    [PressRecognizer],\n  ],\n};\n","import {\n  INPUT_START,\n  INPUT_END,\n  INPUT_CANCEL,\n  INPUT_MOVE,\n  INPUT_TYPE_TOUCH,\n  INPUT_TYPE_MOUSE,\n  INPUT_TYPE_PEN,\n  INPUT_TYPE_KINECT,\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport inArray from '../utils/in-array';\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL,\n};\n\n// in IE10 the pointer types is defined as an enum\nconst IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT, // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nlet POINTER_ELEMENT_EVENTS = 'pointerdown';\nlet POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\nexport default class PointerEventInput extends Input {\n  constructor() {\n    PointerEventInput.prototype.events = `${POINTER_ELEMENT_EVENTS} ${POINTER_WINDOW_EVENTS}`;\n    super(...arguments);\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    this.store = this.manager.session.pointerEvents = [];\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let { store } = this;\n    let removePointer = false;\n\n    let eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    let eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    let pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n    let isTouch = pointerType === INPUT_TYPE_TOUCH;\n\n    // get index of the event in the store\n    let storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n    // start and mouse must be down\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    }\n\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n\n    // update the event in the store\n    store[storeIndex] = ev;\n\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType,\n      srcEvent: ev,\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function removeEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\nexport function removeManagerListeners(manager, types, handler) {\n  each(splitStr(types), (type) => {\n    manager.off(`origin_input:${type}`, handler);\n  });\n}\n","/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nexport default function deprecate(method, name, message) {\n  let deprecationMessage = `DEPRECATED METHOD: ${name}\\n${message} AT \\n`;\n  return function () {\n    let e = new Error('get-stack-trace');\n    let stack =\n      e && e.stack\n        ? e.stack\n            .replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@')\n        : 'Unknown Stack Trace';\n\n    let log = console.warn;\n    if (log) {\n      log(deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n","import deprecate from './deprecate';\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nconst extend = deprecate(\n  (dest, src, merge) => {\n    let keys = Object.keys(src);\n    let i = 0;\n    while (i < keys.length) {\n      if (!merge || (merge && dest[keys[i]] === undefined)) {\n        dest[keys[i]] = src[keys[i]];\n      }\n      i++;\n    }\n    return dest;\n  },\n  'extend',\n  'Use `assign`.',\n);\n\nexport default extend;\n","import deprecate from './deprecate';\nimport extend from './extend';\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nconst merge = deprecate(\n  (dest, src) => {\n    return extend(dest, src, true);\n  },\n  'merge',\n  'Use `assign`.',\n);\n\nexport default merge;\n","import Hammer from './hammer';\nimport assign from './utils/assign';\nimport {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n} from './inputjs/input-consts';\nimport {\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n} from './recognizerjs/recognizer-consts';\nimport {\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from './inputjs/input-consts';\n\nimport Manager from './manager';\nimport Input from './inputjs/input-constructor';\nimport TouchAction from './touchactionjs/touchaction-constructor';\nimport TouchInput from './input/touch';\nimport PointerEventInput from './input/pointerevent';\n\nimport Recognizer from './recognizerjs/recognizer-constructor';\nimport AttrRecognizer from './recognizers/attribute';\nimport TapRecognizer from './recognizers/tap';\nimport PanRecognizer from './recognizers/pan';\nimport SwipeRecognizer from './recognizers/swipe';\nimport PinchRecognizer from './recognizers/pinch';\nimport RotateRecognizer from './recognizers/rotate';\nimport PressRecognizer from './recognizers/press';\n\nimport addEventListeners from './utils/add-event-listeners';\nimport removeEventListeners from './utils/remove-event-listeners';\nimport each from './utils/each';\nimport merge from './utils/merge';\nimport extend from './utils/extend';\nimport inherit from './utils/inherit';\nimport bindFn from './utils/bind-fn';\nimport toArray from './utils/to-array';\nimport uniqueArray from './utils/unique-array';\nimport splitStr from './utils/split-str';\nimport inArray from './utils/in-array';\nimport boolOrFn from './utils/bool-or-fn';\nimport hasParent from './utils/has-parent';\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\n\nexport default assign(Hammer, {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n\n  Manager,\n  Input,\n  TouchAction,\n\n  TouchInput,\n  PointerEventInput,\n\n  Recognizer,\n  AttrRecognizer,\n  Tap: TapRecognizer,\n  Pan: PanRecognizer,\n  Swipe: SwipeRecognizer,\n  Pinch: PinchRecognizer,\n  Rotate: RotateRecognizer,\n  Press: PressRecognizer,\n\n  on: addEventListeners,\n  off: removeEventListeners,\n  each,\n  merge,\n  extend,\n  assign,\n  inherit,\n  bindFn,\n  toArray,\n  inArray,\n  uniqueArray,\n  splitStr,\n  boolOrFn,\n  hasParent,\n  addEventListeners,\n  removeEventListeners,\n});\n","import assign from './assign';\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nexport default function inherit(child, base, properties) {\n  let baseP = base.prototype;\n  let childP;\n\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign(childP, properties);\n  }\n}\n","/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nexport default function hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ifUndefined","val1","val2","undefined","touchMap","round","Math","abs","now","Date","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","forEach","val","INPUT_TYPE_TOUCH","PROPS_XY","PROPS_CLIENT_XY","STATE_FAILED","assign","target","TypeError","output","index","arguments","length","source","nextKey","_uniqueId","each","iterator","context","i","invokeArrayArg","arg","fn","Array","isArray","inArray","src","find","findByKey","indexOf","boolOrFn","args","apply","getRecognizerByNameIfManager","otherRecognizer","recognizer","manager","stateStr","state","Recognizer","options","this","defaults","id","enable","simultaneous","requireFail","touchAction","update","recognizeWith","push","requireFailure","splice","input","emit","event","additionalEvent","canEmit","inputData","inputDataClone","reset","process","tryEmit","AttrRecognizer","optionPointers","pointers","eventType","isRecognized","isValid","attrTest","RotateRecognizer","rotation","threshold","PinchRecognizer","scale","inOut","directionStr","direction","PanRecognizer","pX","pY","actions","DIRECTION_LEFT","DIRECTION_UP","hasMoved","distance","x","deltaX","y","deltaY","directionTest","DIRECTION_HORIZONTAL","SwipeRecognizer","getTouchAction","velocity","overallVelocity","overallVelocityX","overallVelocityY","offsetDirection","maxPointers","bindFn","setTimeoutContext","timeout","setTimeout","getDistance","p1","p2","props","sqrt","TapRecognizer","pTime","pCenter","_timer","_input","count","validPointers","validMovement","validTouchTime","deltaTime","time","failTimeout","validInterval","timeStamp","interval","validMultiTap","center","posThreshold","taps","hasRequireFailures","clearTimeout","tapCount","PressRecognizer","validTime","inStr","str","TouchAction","set","compute","toLowerCase","trim","recognizers","concat","hasPanX","hasPanY","cleanTouchActions","join","srcEvent","session","prevented","preventDefault","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","getCenter","pointersLength","clientX","clientY","simpleCloneInputData","getAngle","atan2","PI","getDirection","getVelocity","inputHandler","pointersLen","changedPointersLen","changedPointers","isFirst","isFinal","firstInput","firstMultiple","offsetCenter","angle","offset","offsetDelta","prevDelta","prevInput","computeDeltaXY","start","end","getRotation","velocityX","velocityY","last","lastInterval","v","computeIntervalInputData","computeInputData","recognize","splitStr","split","addEventListeners","types","handler","type","addEventListener","Input","callback","eventHandler","ev","init","events","on","removeManagerListeners","toArray","slice","uniqueArray","sort","results","values","a","b","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_TARGET_EVENTS","TouchInput","evTarget","targetIds","touches","getTouches","pointerType","targetTouches","allTouches","identifier","changedTouches","changedTargetTouches","Manager","Type","Hammer","handlers","filters","inputClass","item","add","force","stopped","filter","Error","preventDefaults","curRecognizer","canRecognizeWith","existing","remove","data","startsWith","destroy","preset","domEvents","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","PointerEventInput","evEl","evWin","store","pointerEvents","removePointer","eventTypeNormalized","replace","isTouch","storeIndex","pointerId","button","removeEventListeners","removeEventListener","deprecate","method","name","message","deprecationMessage","e","stack","log","console","warn","dest","merge","keys","extend","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","DIRECTION_NONE","DIRECTION_RIGHT","DIRECTION_DOWN","DIRECTION_VERTICAL","DIRECTION_ALL","Tap","Pan","Swipe","Pinch","Rotate","Press","off","inherit","child","base","properties","childP","baseP","create","constructor","_super","hasParent","node","parent","parentNode"],"sourceRoot":""}